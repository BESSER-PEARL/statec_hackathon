#!/usr/bin/env python3
"""Prepare ageing-focused aggregates from the census SDMX extract.

This script consumes the CSV generated by `sdmx_fetch_data.py` for
`DSD_CENSUS_GROUP1_3@DF_B1600` and produces a compact JSON file tailored for
the dashboard. It focuses on three aspects:

* Detailed population counts by 5-year age bands (65+ bands plus children and
  working-age aggregates) for each sex.
* Summary totals for children (0-14), working-age (15-64), and seniors (65+),
  including shares of the total population.
* Old-age dependency ratios (seniors vs. working-age) by sex and overall.
"""

from __future__ import annotations

import csv
import json
from collections import defaultdict
from pathlib import Path
from typing import Dict, Iterable, List

SOURCE_CSV = Path("data/census_age_detail.csv")
OUTPUT_JSON = Path("data/dashboard_data.json")
PUBLIC_JSON = Path("dashboard/public/data/dashboard_data.json")


SUMMARY_GROUPS = {
    "Children (0-14)": ["Y_LT15"],
    "Working-age (15-64)": [
        "Y15T19",
        "Y20T24",
        "Y25T29",
        "Y30T34",
        "Y35T39",
        "Y40T44",
        "Y45T49",
        "Y50T54",
        "Y55T59",
        "Y60T64",
    ],
    "Seniors (65+)": [
        "Y65T69",
        "Y70T74",
        "Y75T79",
        "Y80T84",
        "Y85T89",
        "Y90T94",
        "Y95T99",
        "Y_GE100",
    ],
}


def read_csv(path: Path) -> List[Dict[str, str]]:
    if not path.exists():
        raise SystemExit(f"Expected CSV not found: {path}")
    with path.open(encoding="utf-8") as handle:
        reader = csv.DictReader(handle)
        return list(reader)


def build_detailed_population(rows: Iterable[Dict[str, str]]) -> List[Dict[str, str]]:
    detailed: List[Dict[str, str]] = []
    for row in rows:
        detailed.append(
            {
                "sex": row["SEX_label"],
                "sex_code": row["SEX"],
                "age_band": row["AGE_label"],
                "age_code": row["AGE"],
                "year": int(row["TIME_PERIOD"]),
                "value": int(row["OBS_VALUE"]),
            }
        )
    detailed.sort(key=lambda item: (item["year"], item["sex_code"], item["age_code"]))
    return detailed


def summarise_groups(
    rows: Iterable[Dict[str, str]],
) -> Dict[str, Dict[str, Dict[str, float]]]:
    # Structure: totals[year][sex_code] = total population
    totals: Dict[int, Dict[str, float]] = defaultdict(lambda: defaultdict(float))
    grouped: Dict[int, Dict[str, Dict[str, float]]] = defaultdict(
        lambda: defaultdict(float)
    )

    for row in rows:
        year = int(row["TIME_PERIOD"])
        sex_code = row["SEX"]
        value = float(row["OBS_VALUE"])
        totals[year][sex_code] += value
        for label, codes in SUMMARY_GROUPS.items():
            if row["AGE"] in codes:
                grouped[year][(sex_code, label)] += value

    return {
        "totals": totals,
        "grouped": grouped,
    }


def build_summary(
    rows: Iterable[Dict[str, str]]
) -> List[Dict[str, float]]:
    summary_info = summarise_groups(rows)
    totals = summary_info["totals"]
    grouped = summary_info["grouped"]
    summary_rows: List[Dict[str, float]] = []

    for year, sex_totals in totals.items():
        for sex_code, total_value in sex_totals.items():
            sex_label = next(
                (row["SEX_label"] for row in rows if int(row["TIME_PERIOD"]) == year and row["SEX"] == sex_code),
                sex_code,
            )
            for label, codes in SUMMARY_GROUPS.items():
                key = (sex_code, label)
                value = grouped[year].get(key, 0.0)
                share = (value / total_value * 100) if total_value else 0.0
                summary_rows.append(
                    {
                        "year": year,
                        "sex": sex_label,
                        "sex_code": sex_code,
                        "group": label,
                        "value": round(value),
                        "share": round(share, 2),
                    }
                )
    summary_rows.sort(key=lambda item: (item["year"], item["sex_code"], item["group"]))
    return summary_rows


def build_dependency_ratios(
    rows: Iterable[Dict[str, str]]
) -> List[Dict[str, float]]:
    summary_info = summarise_groups(rows)
    totals = summary_info["totals"]
    grouped = summary_info["grouped"]

    ratios: List[Dict[str, float]] = []
    for year, sex_totals in totals.items():
        for sex_code in sex_totals:
            seniors = grouped[year].get((sex_code, "Seniors (65+)"), 0.0)
            working = grouped[year].get((sex_code, "Working-age (15-64)"), 0.0)
            ratio = (seniors / working * 100) if working else 0.0
            sex_label = next(
                (row["SEX_label"] for row in rows if int(row["TIME_PERIOD"]) == year and row["SEX"] == sex_code),
                sex_code,
            )
            ratios.append(
                {
                    "year": year,
                    "sex": sex_label,
                    "sex_code": sex_code,
                    "old_age_dependency_ratio": round(ratio, 2),
                }
            )
    ratios.sort(key=lambda item: (item["year"], item["sex_code"]))
    return ratios


def main() -> None:
    rows = read_csv(SOURCE_CSV)
    detailed = build_detailed_population(rows)
    summary = build_summary(rows)
    dependency = build_dependency_ratios(rows)

    output = {
        "updated_at": SOURCE_CSV.stat().st_mtime,
        "year": detailed[0]["year"] if detailed else None,
        "population_detailed": detailed,
        "population_summary": summary,
        "old_age_dependency": dependency,
    }

    payload = json.dumps(output, indent=2)
    OUTPUT_JSON.write_text(payload, encoding="utf-8")
    if PUBLIC_JSON.parent.exists():
        PUBLIC_JSON.write_text(payload, encoding="utf-8")
    print(f"Wrote dashboard dataset to {OUTPUT_JSON}")

    if PUBLIC_JSON.parent.exists():
        print(f"Synced dashboard dataset to {PUBLIC_JSON}")


if __name__ == "__main__":
    main()
